class Solution {
    private:
    bool f(int node,vector<int>adj[],vector<bool>&vis,vector<bool>&dfsvis){
        vis[node]=1;
        dfsvis[node]=1;
        for(auto x:adj[node]){
            if(vis[x]==false){
                if(f(x,adj,vis,dfsvis)){
                    return true;
                }
            }else{
                if(dfsvis[x]){return true;}
            }
        }
        dfsvis[node]=0;
        return false;
    }
public:
    bool canFinish(int N, vector<vector<int>>& arr) {
        vector<int>adj[N];
	    for(auto x:arr){
	        adj[x[0]].push_back(x[1]);
	    }
         vector<bool>vis(N,false);
         vector<bool>dfsvis(N,false);

//DFS
    for(int i=0;i<N;++i){
        if(vis[i]==false){
            if(f(i,adj,vis,dfsvis)){return false;}
        }
    }
    return true;

	   // BFS Kahns Topo sort
	    // vector<int>indegree(N,0);
	    // for(int i=0;i<N;++i){
	    //     for(auto x:adj[i]){
	    //         indegree[x]++;
	    //     }
	    // }
	    // queue<int>q;
	    // for(int i=0;i<N;++i){
	    //     if(indegree[i]==0){
	    //         q.push(i);
	    //     }
	    // }
	    // int ct=0;
	    // while(!q.empty()){
	    //     auto temp=q.front();
	    //     q.pop();
	    //     ++ct;
	    //     for(auto x:adj[temp]){
	    //         indegree[x]--;
	    //         if(indegree[x]==0){
	    //             q.push(x);
	    //         }
	    //     }
	    // }
	    // return (ct==N);
    }
};